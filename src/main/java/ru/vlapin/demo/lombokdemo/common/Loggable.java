package ru.vlapin.demo.lombokdemo.common;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.RetentionPolicy.*;
import static ru.vlapin.demo.lombokdemo.common.Loggable.LogLevel.*;

import java.lang.annotation.Retention;
import java.lang.annotation.Target;
import java.util.function.BiConsumer;
import lombok.SneakyThrows;
import lombok.experimental.ExtensionMethod;
import lombok.extern.slf4j.Slf4j;
import lombok.val;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

/**
 * An aspect annotation used to mark a class or method for logging purposes. It allows specifying
 * the logging level to control the granularity of the logged messages.
 * <p>
 * The {@code Loggable} annotation can be applied to types or methods. When applied,
 * it indicates that operations within the annotated scopes should generate log entries
 * at the specified {@link LogLevel}. By default, the logging level is set to {@code DEBUG}.
 * <p>
 * The {@code LogLevel} enumeration defines the following levels of logging:
 * <ul>
 *  <li>{@link Loggable.LogLevel#ERROR}: Logs error messages</li>
 *  <li>{@link Loggable.LogLevel#WARN}: Logs warning messages</li>
 *  <li>{@link Loggable.LogLevel#INFO}: Logs informational messages</li>
 *  <li>{@link Loggable.LogLevel#DEBUG}: Logs debugging messages</li>
 *  <li>{@link Loggable.LogLevel#TRACE}: Logs detailed trace messages</li>
 * </ul>
 * @see LoggableAspect#aroundAdvice(ProceedingJoinPoint)
 */
@Retention(RUNTIME)
@Target({TYPE, METHOD})
public @interface Loggable {

  /**
   * Specifies the logging level for the annotated element.
   *
   * @return the logging level, which defaults to {@link LogLevel#DEBUG}.
   */
  LogLevel value() default DEBUG;

  /**
   * Represents the various levels of logging granularity.
   * <p>
   * This enumeration defines different logging levels that can be used to control
   * the verbosity of log messages. Each level indicates the severity or detail of
   * the log entry:
   * <ul>
   *   <li>{@link Loggable.LogLevel#ERROR}: Critical issue indicating a failure in the application</li>
   *   <li>{@link Loggable.LogLevel#WARN}: Potential issue or important runtime condition that should be observed</li>
   *   <li>{@link Loggable.LogLevel#INFO}: General runtime information or events</li>
   *   <li>{@link Loggable.LogLevel#DEBUG}: More verbose information intended for debugging purposes</li>
   *   <li>{@link Loggable.LogLevel#TRACE}: Highly detailed logs for diagnosing complex issues</li>
   </ul>
   */
  enum LogLevel {

    /**
     * Represents the log level that indicates a critical issue or failure in the application.
     * This level is used to log messages about severe problems that require immediate attention.
     */
    ERROR,

    /**
     * Represents the log level that indicates a potential issue or an important runtime condition
     * that should be observed.
     * This level is typically used to log warnings about situations that are not errors but might
     * warrant attention or are worthy of investigation.
     */
    WARN,

    /**
     * Represents the log level that indicates general runtime information or events.
     * This level is typically used to record informational messages that highlight
     * the progress of the application at a coarse-grained level.
     */
    INFO,

    /**
     * Represents the log level that indicates more verbose information intended
     * for debugging purposes. This level is generally used to log detailed messages
     * that assist in diagnosing and troubleshooting issues in an application.
     */
    DEBUG,

    /**
     * Represents the log level that indicates highly detailed logs intended for diagnosing
     * complex issues. This level is generally used to record fine-grained informational events
     * that are helpful during development and debugging.
     */
    TRACE
  }
}

/**
 * A custom annotation that enables logging functionality at the {@code INFO} log level.
 * <p>
 * The {@code LogInfo} annotation is a specialization of the {@code Loggable} annotation
 * and is used to explicitly indicate that log messages generated by the annotated
 * element should have an {@code INFO} granularity. It simplifies usage by
 * predefining the logging level as {@code INFO}.
 * <p>
 * This annotation can be applied to classes or methods to indicate that informational
 * messages related to the annotated element's execution should be logged.
 *
 * @see Loggable
 * @see Loggable.LogLevel#INFO
 */
@Loggable(INFO)
@interface LogInfo {
}

/**
 * Aspect for enabling logging capabilities for methods or classes annotated with {@link Loggable}.
 * This class intercepts method execution and logs method calls along with their arguments and results.
 * The logging level depends on the value of the {@link Loggable} annotation applied to the method or class.
 */
@Slf4j
@Aspect
@ExtensionMethod(AspectUtils.class)
final class LoggableAspect {

  /**
   * Defines a pointcut that matches methods or classes annotated with {@code @}{@link Loggable},
   * including deeply nested levels of meta-annotation (annotations annotated with {@code @}{@link Loggable}).
   * <p>
   * The pointcut will trigger for:
   * <ul>
   *   <li>Methods annotated directly with {@code @}{@link Loggable}</li>
   *   <li>Methods within classes annotated with {@code @}{@link Loggable}</li>
   *   <li>Methods annotated with a meta-annotation of {@code @}{@link Loggable}, up to multiple nesting levels (&lt;9)</li>
   *   <li>Methods within classes that are annotated with meta-annotations of {@code @}{@link Loggable}, up to multiple nesting levels (&lt;9)</li>
   * </ul>
   * The expression defines matching rules for various combinations of method execution and
   * class/package-level annotations.
   */
  @Pointcut("""
      @annotation(Loggable) || within(@Loggable *)\
      || execution(@(@Loggable *) * *(..)) || within (@(@Loggable *) *)\
      || execution(@(@(@Loggable *) *) * *(..)) || within (@(@(@Loggable *) *) *)\
      || execution(@(@(@(@Loggable *) *) *) * *(..)) || within (@(@(@(@Loggable *) *) *) *)\
      || execution(@(@(@(@(@Loggable *) *) *) *) * *(..)) || within (@(@(@(@(@Loggable *) *) *) *) *)\
      || execution(@(@(@(@(@(@Loggable *) *) *) *) *) * *(..)) || within (@(@(@(@(@(@Loggable *) *) *) *) *) *)\
      || execution(@(@(@(@(@(@(@Loggable *) *) *) *) *) *) * *(..)) || within (@(@(@(@(@(@(@Loggable *) *) *) *) *) *) *)\
      || execution(@(@(@(@(@(@(@(@Loggable *) *) *) *) *) *) *) * *(..)) || within (@(@(@(@(@(@(@(@Loggable *) *) *) *) *) *) *) *)""")
  void pointcut() {
  }

  /**
   * Intercepts and logs method calls with arguments/result
   */
  @SneakyThrows
  @Around("pointcut()")
  Object aroundAdvice(ProceedingJoinPoint pjp) {
    val methodName = pjp.getSignature().getName();
    val args = pjp.getArgs();
    val logMethod = getLogMethod(pjp);

    logMethod.accept("Метод {} был вызван с аргументами {}", new Object[]{methodName, args});

    val result = pjp.proceed();

    logMethod.accept("Method {} вернул {} для аргументов {}", new Object[]{methodName, result, args});

    return result;
  }

  private static BiConsumer<String, Object[]> getLogMethod(ProceedingJoinPoint pjp) {
    return switch (pjp.getAnnotation(Loggable.class).value()) {
      case INFO -> log::info;
      case DEBUG -> log::debug;
      case WARN -> log::warn;
      case ERROR -> log::error;
      case TRACE -> log::trace;
    };
  }
}
